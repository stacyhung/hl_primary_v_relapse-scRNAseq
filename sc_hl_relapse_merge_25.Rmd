---
title: "Seurat_analysis"
author: "Stacy Hung"
date: "02/12/2019"
output: html_document
---

This script is based on vignettes from the Seurat website:
https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html
https://satijalab.org/seurat/v3.1/merge_vignette.html

```{r}
library(dplyr)
library(Seurat)
library(tidyr)
library(grid)
library(ggplot2)
library(sctransform)
```

## Examine QC metrics

```{r}
metrics <- read.table("~/Documents/sc_HL_relapse/metrics/all.relapse.metrics.txt", sep = "\t", header = TRUE, fill = TRUE)

# Liz's favourite metrics:
  # 1. cells recovered --> "Estimated.Number.of.Cells"
  # 2. mean reads per cell --> "Mean.Reads.per.Cell" 
  # 3. median genes per cell --> "Median.Genes.per.Cell"
  # 4. % sequencing saturation --> "Sequencing.Saturation"

# Other relevant metrics:
  # "Fraction.Reads.in.Cells"
  # "Total.Genes.Detected"

keeps <- c("SampleID", "Estimated.Number.of.Cells", "Mean.Reads.per.Cell", "Median.Genes.per.Cell", "Sequencing.Saturation", "Fraction.Reads.in.Cells", "Total.Genes.Detected")
metrics <- metrics[c(keeps)]
colnames(metrics) <- c("SampleID", "Est. Number of Cells", "Mean Reads / Cell", "Median Genes / Cell", "Sequencing Saturation (%)", "Fraction Reads in Cells (%)", "Total Genes Detected")

# convert from wide to long
metrics.long <- gather(metrics, metric, value, "Est. Number of Cells":"Total Genes Detected")

# faceted barplot for metrics of interest, and bars coloured by relapse vs. primary
p <- ggplot(metrics.long, aes(x = SampleID, y = value)) + 
      geom_bar(stat = "identity", fill="steelblue", width = 0.8) + 
      facet_wrap( ~ metric, scales = "free") + 
      xlab("") + ylab("") + 
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 8)) +
      theme(panel.spacing = unit(1, "lines"))
p
```

## Read in the dataset and create a Seurat object - to serve as a container for both data (e.g. count matrix) and analyses (e.g. PCA, clustering, etc.) for a single-cell dataset.  See https://github.com/satijalab/seurat/wiki for technical details on the Seurat object.

```{r}
## Define dataset for analysis
dataset_loc <- "~/Documents/sc_HL_relapse/cellranger-3.1.0"
ids <- c("cHL-LSARP-01", "cHL-LSARP-02", "cHL-LSARP-03", "cHL-LSARP-06", "cHL-LSARP-07", "cHL-LSARP-08", "cHL-LSARP-05", "cHL-LSARP-09", "cHL-LSARP-10", "cHL-LSARP-11", "cHL-LSARP-12", "cHL-LSARP-13", "cHL-LSARP-14", "cHL-LSARP-15", "cHL-LSARP-16", "cHL-LSARP-17", "cHL-LSARP-18", "cHL-LSARP-19", "cHL-LSARP-20", "cHL-LSARP-21", "cHL-LSARP-22", "cHL-LSARP-23", "cHL-LSARP-24", "cHL-LSARP-25", "cHL-LSARP-26")

# Note that 10X has an aggr function that combines multiple samples into a single count matrix, but for Seurat analysis, this is actually counterproductive since we will lose sample ids, so we will read in by sample here:
d10x.data <- sapply(ids, function(i) {
  d10x <- Read10X(file.path(dataset_loc, i, ""))
  colnames(d10x) <- paste(sapply(strsplit(colnames(d10x), split="-"), '[[', 1L), i, sep="_")
                          d10x
})

experiment.data <- do.call("cbind", d10x.data)

hl_relapse.merged <- CreateSeuratObject(
  experiment.data,
  project = "hl relapse merged",
  min.cells = 10, # keep all genes that are expressed in at least 3 cells --> might be too lenient for scTransform
  min.features = 200, # keep all cells that are expressing at least 200 transcripts
  names.field = 2, # the sample id is in the 2nd column after applying the delimiter "_"
  names.delim = "\\_" # the delimiter
)
# total of 106,831 cells across 25 samples (average ~4K cells)

# add "relapse" label (in case we want to combine it with primary HL data later)
hl_relapse.merged[["case.type"]] <- "relapse"
```

## Add metadata for batch correction

```{r}
samples <- hl_relapse.merged@meta.data$orig.ident
sample.num_cells <- as.data.frame(table(samples))
colnames(sample.num_cells) <- c("sample", "num_cells")

# plot numbers of cells per sample, ordered by increasing numbers of cells
p2 <- ggplot(sample.num_cells, aes(x = reorder(sample, -num_cells), y = num_cells)) + 
      geom_bar(stat = "identity", fill="steelblue", width = 0.8) + 
      xlab("") + ylab("") + 
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 8)) +
      theme(panel.spacing = unit(1, "lines"))
p2

# for both datasets, sample names are under the "Sample" column and the "batch" would be the "GSCFlowcell" column
hl_relapse.metadata <- read.table("~/Documents/sc_HL_relapse/data/relapse/library_info-relapse-cohort.txt", sep = "\t", header = TRUE, fill = TRUE)

# map batch information to orig.idents 
hl_relapse.merged$batch <- plyr::mapvalues(
    x = hl_relapse.merged$orig.ident, 
    from = hl_relapse.metadata$Sample, 
    to = hl_relapse.metadata$GSCFlowcell
)

hl_relapse.merged$chip <- plyr::mapvalues(
    x = hl_relapse.merged$orig.ident, 
    from = hl_relapse.metadata$Sample, 
    to = hl_relapse.metadata$Chip
)
```

Standard pre-processing workflow:

  1) Selection and filtration of cells based on QC metrics
  2) Data normalization, scaling, and detection of highly variable features (NEW: SCTransform function)

## (1) Examine mitochondrial content and filter accordingly

Metrics commonly used by the community:
* Number of unique genes detected in each cell
    => Low-quality cells / empty droplets will often have very few genes
    => Cell doublets / multiplets may exhibit an aberrantly high gene count
* Total number of molecules detected in each cell (strongly correlated with unique genes)
* % of reads that map to mitochondrial genome
    => low-quality / dying cells often exhibit extensive mitochondrial contamination

```{r}
# Get % reads that map to mitochondrial genome - add as column in metadata 
# The `PercentageFeatureSet` function calculates % counts originating from a set of features - use set of genes starting with "MT-" as set of mitochondrial genes

hl_relapse.merged[["percent.mt"]] <- PercentageFeatureSet(hl_relapse.merged, pattern = "^MT-")
head(hl_relapse.merged@meta.data, 5)

# Visualization transcript information by sample
VlnPlot(hl_relapse.merged, 
        features = c("nFeature_RNA", "percent.mt"),
        sort = "increasing", log = FALSE,
        ncol = 2, pt.size = 0)

scatter.1 <- FeatureScatter(hl_relapse.merged, feature1 = "nCount_RNA",  feature2 = "percent.mt")
scatter.2 <- FeatureScatter(hl_relapse.merged, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
CombinePlots(plots = list(scatter.1, scatter.2))

# Filter out cells that have between 200-2500 unique features / genes and have less than 20 % mitochondria
hl_relapse.merged <- subset (hl_relapse.merged, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 20)
# Now working with 80,831 cells across 25 samples (average 3.2K cells)
# or 76,607 cells using < 20% MT filter (average 3K cells)
```

## (2) Normalize, scale and find variable features

SCTransform now replaces all of:

* Application of global-scaling normalization method `LogNormalize`
  - Normalizes feature expression measurements for each cell by total expression
  - Multiplies this by a scale factor (10,000 by default) and log-transforms the result

* Application of the linear transformation `ScaleData` function:
  - Shifts the expression of each gene, so that mean expression across cell is 0
  - Scales the expression of each gene, so that variances across cells is 1
    - This step gives equal weight in downstream analysis, so highly expressed genes do not dominate
  - Result is stored in SeuratObject[["RNA"]]@scale.data

* Application of `FindVariableFeatures`, to identify features with high cell-to-cell variation
  - E.g. highly expressed in some cells, lowly expressed in others
  - Focusing on these genes in downstream analysis (e.g. PCA) helps to highlight biological signal
  - Implemented with , which returns 2000 features by default

************************************************************************************************************
*NB: The sctransform normalization reveals sharper biological distinctions compared to the standard worklow, specifically:
  - Clear separation of at least 3 CD8 T cell populations (naive, memory, effector), based on CD8A, GZMK, CCL5, GZMK expression
  - Clear separation of three CD4 T cell populations (naive, memory, IFN-activated) based on S100A4, CCR7, IL32, and ISG15
  - Additional developmental sub-structure in B cell cluster, based on TCL1A, FCER2
  - Additional separation of NK cells into CD56dim vs. bright clusters, based on XCL1 and FCGR3A

************************************************************************************************************

```{r}
# previous workflow:

hl_relapse.merged <- NormalizeData(hl_relapse.merged, normalization.method = "LogNormalize", scale.factor = 10000)
hl_relapse.merged <- FindVariableFeatures(hl_relapse.merged, selection.method = "vst", nfeatures = 2000)
hl_relapse.merged <- ScaleData(hl_relapse.merged, vars.to.regress = c("batch", "chip", "percent.mt"), verbose = FALSE)

# plot the 30 most highly variable genes
top30 <- head(VariableFeatures(hl_relapse.merged), 30)
plot1 <- VariableFeaturePlot(hl_relapse.merged)
plot2 <- LabelPoints(plot = plot1, points = top30, repel = TRUE)

# Very memory-intensive
hl_relapse.merged <- SCTransform(hl_relapse.merged, 
                                 vars.to.regress = c("batch", "chip", "percent.mt"), 
                                 verbose = TRUE,
                                 conserve.memory = TRUE)
```

## Output from SCTransform (applied gc(full=TRUE) and rm() for all other objects to maximum memory available)

```{r}
#Calculating cell attributes for input UMI matrix
#Variance stabilizing transformation of count matrix of size 20313 by 76607
#Model formula is y ~ log_umi
#Get Negative Binomial regression parameters per gene
#Using 2000 genes, 76607 cells  |======================================================================================================| 100%
#...iteration limit reached...

#Found 6 outliers - those will be ignored in fitting/regularization step
#
#Skip calculation of full residual matrix
#Will not return corrected UMI because residual type is not set to 'pearson'Calculating gene attributes
#Wall clock passed: Time difference of 19.82973 mins
#Calculating variance for residuals of type pearson for 20313 genes
#  |======================================================================================================| 100%

#Determine variable features
#Set 3000 variable features
#Return only variable features for scale.data slot of the output assay
#Calculating residuals of type pearson for 3000 genes
#  |======================================================================================================| 100%

#Computing corrected UMI count matrix
#  |======================================================================================================| 100%

#Place corrected count matrix in counts slot
#Regressing out batch, chip, percent.mt
#  |======================================================================================================| 100%

#Centering data matrix
#  |======================================================================================================| 100%

#Set default assay to SCT
```

## Perform linear dimensional reduction

```{r}
# Perform PCA on the scaled data
hl_relapse.merged <- RunPCA(hl_relapse.merged)
#hl_relapse.merged <- RunPCA(hl_relapse.merged, features = VariableFeatures(object = hl_relapse.merged))

# Examine PCA results
print(hl_relapse.merged[["pca"]], dims = 1:5, nfeatures = 30)

# Visualize loadings
VizDimLoadings(hl_relapse.merged, dims = 1:2, reduction = "pca")
DimPlot(hl_relapse.merged, reduction = "pca")
DimHeatmap(hl_relapse.merged, dims=1:15, cells = 500, balanced = TRUE)
```

## Output of RunPCA

```{r}
#PC_ 1 
#Positive:  IL32, CXCL13, TRBC1, SRGN, CD3D, TRAC, CCL5, CD7, CD2, FYB1 
#	   NKG7, KLRB1, GZMK, TRBC2, NEAT1, GIMAP7, IL7R, CYTOR, GIMAP4, CD3E 
#	   LAG3, MAF, CD3G, LAT, S100A4, SYNE2, SPOCK2, GZMA, TSHZ2, TNFRSF4 
#Negative:  IGKC, HLA-DRA, IGLC2, CD74, IGHM, HLA-DRB1, IGLC3, HLA-DPB1, HLA-DPA1, MS4A1 
#	   HLA-DQA1, HLA-DQB1, CD79A, TCL1A, CD79B, IGHD, BANK1, MEF2C, HLA-DMA, HLA-DMB 
#	   CD22, CD37, BCL11A, VPREB3, FCER2, CD72, CD83, RALGPS2, HLA-DRB5, POU2F2 
#PC_ 2 
#Positive:  CXCL13, TRBC1, TSHZ2, TRAC, THADA, FYB1, MAF, TNFRSF4, IL6ST, CD3D 
#	   PTPN13, FKBP5, SPOCK2, TRBC2, PASK, LAT, CTLA4, CD4, ITM2A, ICOS 
#	   LGMN, IL6R, CORO1B, MIR4435-2HG, TCF7, LIMS1, TOX2, CD40LG, AC004585.1, IL32 
#Negative:  NKG7, CCL5, GNLY, GZMA, GZMK, KLRD1, GZMB, PRF1, GZMH, CCL4 
#	   KLRC1, TYROBP, CTSW, TRDC, FCER1G, CST7, XCL2, KLRF1, XCL1, CMC1 
#	   FCGR3A, CD8A, CCL3, HOPX, PTGDR, EOMES, FGFBP2, CD160, CCL4L2, KLRC2 
#PC_ 3 
#Positive:  IGKC, CXCL13, IGKV3-20, IGKV3-11, IGKV4-1, IGHG1, IGHG2, HLA-DRB1, IGKV3-15, IGKV1-5 
#	   IGLC5, SRGN, HLA-DQA1, JCHAIN, IGKV1-39, HSP90B1, MZB1, XBP1, CD83, HLA-DQB1 
#	   LAG3, HLA-DRA, CD74, IGHG4, PARP14, HLA-DPA1, CCL3, ISG15, IGHG3, TYMP 
#Negative:  IGLC2, IGLC3, IGLC7, IGLC6, IGLV6-57, IGLV2-14, IGLV1-44, IGLV1-40, JUN, IFT57 
#	   IGLV3-19, IGLV4-69, IGLV3-25, IGLV3-21, IGLV2-23, IGLV1-47, IL7R, IGLV2-8, KLF2, TXNIP 
#	   TPT1, RPS12, IGLV1-51, RPS27, IGLV2-11, LINC01781, RPL34, IGHV4-39, EEF1A1, AC245014.3 
#PC_ 4 
#Positive:  IL7R, RPS12, TPT1, VIM, RPS6, RPS18, RPL10, RPL21, RPL34, GIMAP7 
#	   EEF1A1, CCR7, ANXA1, RPLP2, RPS27, LDHB, RPL39, RPS4X, NOSIP, RPS29 
#	   TXNIP, ZFP36L2, RPL31, RPL13A, EEF1B2, GIMAP1, RPL41, TCF7, LEF1, RPL27A 
#Negative:  CXCL13, SRGN, IGKC, IGLC2, LAG3, HLA-DRA, IL32, HLA-DRB1, CD74, CTLA4 
#	   CYTOR, TNFRSF4, MAF, TNIP3, LGMN, IGHM, MIR4435-2HG, IGLC3, TNFRSF18, RGS1 
#	   NEAT1, LINC01943, HLA-DPA1, DUSP2, HLA-DQA1, CD7, MS4A1, PTMS, HLA-DQB1, HLA-DPB1 
#PC_ 5 
#Positive:  IGLC2, IGKC, JUN, FOS, JUNB, DUSP1, IL7R, FOSB, IER2, TSC22D3 
#	   KLF2, EGR1, TUBA1A, DNAJB1, CD69, ZFP36L2, KLF6, VIM, H3F3B, RPS12 
#	   TPT1, HSPA1B, ZFP36, ANXA1, TCF7, RHOB, GIMAP7, BTG2, RPS18, SLC2A3 
#Negative:  IGLC3, IGLC7, IGLC6, CD74, IGHM, LAG3, SRGN, CXCL13, HLA-DRA, IGLV1-47 
#	   JCHAIN, MAF, HLA-DQA2, MZB1, HLA-DRB5, MEF2C, IL4R, TNFRSF4, LGMN, IGLV1-44 
#	   CTLA4, HLA-DMB, TNIP3, TNFRSF18, CST3, CD79B, MIR4435-2HG, FCRL5, CYTOR, IGHD
```

## Determine the "dimensionality" of the dataset

```{r}
# doesn't work
#JackStrawPlot(hl_relapse.merged)

# Looks like the first 20 PCs are important
ElbowPlot(hl_relapse.merged)
```

## Cluster the cells

```{r}
hl_relapse.merged <- FindNeighbors(hl_relapse.merged, dims = 1:20)
hl_relapse.merged <- FindClusters(hl_relapse.merged, resolution = 0.8)

# look at the cluster IDs of the first 5 cells
head(Idents(hl_relapse.merged), 5)
```

## Run non-linear dimensional reduction (UMAP)

```{r}
hl_relapse.merged <- RunUMAP(hl_relapse.merged, dims = 1:20)

# Visualize UMAP
DimPlot(hl_relapse.merged, label = TRUE) + NoLegend()

# Save object so that it can be loaded without having to re-run computationally intensive steps again
saveRDS(hl_relapse.merged, file = "~/Documents/sc_HL_relapse/seurat/output/hl_relaspe_25-merged-sctransform_workflow.rds") # 2.8 Gb
```

## Annotate clusters based on canonical markers

```{r}
# Seurat's sctransform function allows:
#  1. Clear separation of naive, memory and effector CD8 T-cell populations based on CD8A, GZMK, and CCL5 expression
#  2. Clear separation of naive, memory, and IFN-activated CD4 T-cell populations based on S100A4, CCR7, IL32 and ISG15
#  3. Developmental sub-structure in B-cell cluster based on TCL1A and FCER2
#  4. Separation of NK cells into CD56dim vs. bright clusters, based on XCL1 and FCGR3A



```






```{r}
# run the standard workflow for visualization and clustering
hl_relapse <- RunPCA(hl_relapse, npcs = 30, verbose = FALSE)

# UMAP, t-SNE and clustering
hl_relapse <- RunUMAP(hl_relapse, reduction = "pca", dims = 1:20) # default parameters

# UMAP embedding parameters a = 0.9922 b = 1.112
hl_relapse <- FindNeighbors(hl_relapse, reduction = "pca", dims = 1:20)
hl_relapse <- FindClusters(hl_relapse, resolution = 0.5)

```

4c. Visualization

```{r}
library(cowplot)

# show umap coloured by case type (i.e. primary vs. relapse)
p1 <- DimPlot(hl.combined, reduction = "umap", group.by = "case_type")
# show umap coloured by clusters
p2 <- DimPlot(hl.combined, reduction = "umap", label = TRUE)
# show the two plots side by side
plot_grid(p1, p2)

# show umap coloured by sample
p3 <- DimPlot(hl_relapse, reduction = "umap", group.by = "orig.ident")

# show umap of each case case type, coloured by cluster
DimPlot(hl.combined, reduction = "umap", split.by = "case_type")
``` 

5. Identify conserved cell type markers

Use the `FindConservedMarkers` function to identify canonical cell type marker genes that are conserved across conditions - this function performs differential gene expression for each dataset/group and combines p-values using meta-analysis methods from the MetaDE R package.

```{r}
DefaultAssay(hl.combined) <- "RNA"
cluster10.markers <- FindConservedMarkers(hl.combined, 
                                          ident.1 = "10_primary", 
                                          grouping.var = "case_type", 
                                          verbose = FALSE)

write.table(cluster10.markers, "/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/seurat/output/integration-primary+relapse-cluster10_markers_in_relapse.txt", sep = "\t", quote = FALSE)

# plot biomarkers for cell components

# B and T cell cells
FeaturePlot(hl.combined, features = c("CD3D", "MS4A1"), min.cutoff = "q9")
```

Feature plots for biomarkers of each cell component

```{r}
# B cells: CD19, MS4A1, IGHD
FeaturePlot(hl.combined, features = c("CD19", "MS4A1", "IGHD"),  min.cutoff = "q9") # right hemisphere
# T cells: CD3D, CD8B, CD4
FeaturePlot(hl.combined, features = c("CD3D", "CD8B", "CD4"),  min.cutoff = "q9") # left hemisphere
# Plasma cell: SDC1
FeaturePlot(hl.combined, features = c("SDC1"),  min.cutoff = "q9") # cluster 19
# NK cell: NCAM1
FeaturePlot(hl.combined, features = c("NCAM1"),  min.cutoff = "q9") # very few cells, no cluster
# Plasmacytoid DC: CLEC4C, NRP1
FeaturePlot(hl.combined, features = c("CLEC4C", "NRP1"),  min.cutoff = "q9") # cluster 18 + scattered
# Macrophage: CD68, IL3RA, IDO1
FeaturePlot(hl.combined, features = c("CD68", "IL3RA", "IDO1"),  min.cutoff = "q9") # scattered
# Progenitor: CD34
FeaturePlot(hl.combined, features = c("CD34"),  min.cutoff = "q9") # scattered
# Naive T-cell: CCR7, IL7R, LEF1, SELL
FeaturePlot(hl.combined, features = c("CCR7", "IL7R", "LEF1", "SELL"),  min.cutoff = "q9") # scattered
# Memory T-cell: CD44
FeaturePlot(hl.combined, features = c("CD44"),  min.cutoff = "q9") # scattered
# Transcription factor: EOMES --> cluster 9, ID2 --> cluster 14, 17, and B cells
FeaturePlot(hl.combined, features = c("EOMES", "ID2"),  min.cutoff = "q9") 
# Inhibitory receptor: TIGIT, HAVCR2, CTLA4, LAG3, CD274, PDCD1
FeaturePlot(hl.combined, features = c("TIGIT", "HAVCR2", "CTLA4", "LAG3", "CD274", "PDCD1"),  min.cutoff = "q9") # scattered
# Effector molecule: GZMA, GZMK 
FeaturePlot(hl.combined, features = c("GZMA", "GZMK"),  min.cutoff = "q9")  # cluster 9
# Co-stimulatory molecule: ICOS, ICOSLG, CD28, TNFRSF18, TNFRSF8, CD40LG
FeaturePlot(hl.combined, features = c("ICOS", "ICOSLG", "CD28", "TNFRSF18", "TNFRSF8", "CD40LG"),  min.cutoff = "q9") # scattered
# T helper: CXCR5, BCL6, KLRB1, CCR4, TBX21, GATA3
FeaturePlot(hl.combined, features = c("CXCR5", "BCL6", "KLRB1", "CCR4", "TBX21", "GATA3"),  min.cutoff = "q9") # scattered
# Cytokine / chemokine: IL2, IL4, IFNG
FeaturePlot(hl.combined, features = c("IL2", "IL4", "IFNG"),  min.cutoff = "q9")
# LAG3 + Tregs (FOXP3, IL2RA, IKZF2)
FeaturePlot(hl.combined, features = c("FOXP3", "IL2RA", "IKZF2", "CTLA4", "LAG3"), min.cutoff = "q9") # clusters 5, 12
```

```{r}
# biomarkers that correspond to a distinct cluster
FeaturePlot(hl.combined, features = c("SDC1", "NRP1", "GZMK"),  min.cutoff = "q9", ncol = 3)

# examine expression of LAG3 and CTLA4 in primary vs. relapse cases
FeaturePlot(hl.combined, features = c("FOXP3", "IL2RA", "IKZF2", "CTLA4", "LAG3"), min.cutoff = "q9", split.by = "case_type") # clusters 5, 12

# annotate clusters that have clear biomarker expression
hl.combined <- RenameIdents(hl.combined, 
                            `19` = "Plasma Cells", 
                            `18` = "Plasmacytoid DC", 
                            `9` = "Effector Molecules")
# renaming second round:
hl.combined <- RenameIdents(hl.combined, 
                            `0` = "Plasma Cells", 
                            `1` = "Plasmacytoid DC", 
                            `2` = "Naive T cells",
                            `3` = "Naive T cells",
                            `4` = "B cells",
                            `5` = "Tregs",
                            `6` = "B cells",
                            `7` = "B cells",
                            `8` = "B cells",
                            `10` = "Naive T cells",
                            `11` = "Naive T cells",
                            `12` = "Tregs",
                            `13` = "B cells",
                            `14` = "NK cells",
                            `15` = "CD4 T cells",
                            `16` = "germinal centre B cells",
                            `17` = "macrophages",
                            `Effector Molecules` = "Cytotoxic T cells")

DimPlot(hl.combined, label = TRUE, repel = TRUE)

# display expression dot plot to show conservation of biomarkers by cluster between primary and relapse cases
#Idents(hl.combined) <- factor(Idents(hl.combined), levels = c("Mono/Mk Doublets", "pDC", "Eryth", "Mk", "DC", "CD14 Mono", "CD16 Mono", "B Activated", "B", "CD8 T", "NK", "T activated", "CD4 Naive T", "CD4 Memory T"))
markers.to.plot <- c("CD3D", "CD8B", "CD4", "CD19", "MS4A1", "IGHD", "SDC1", "NCAM1", "CLEC4C", "NRP1", "CD68", "IL3RA", "IDO1", "CD34", "CCR7", "IL7R", "LEF1", "SELL", "CD44", "EOMES", "ID2", "TIGIT", "HAVCR2", "CTLA4", "LAG3", "CD274", "PDCD1", "GZMA", "GZMK", "ICOS", "ICOSLG", "CD28", "TNFRSF18", "TNFRSF8", "CD40LG", "FOXP3", "IL2RA", "IKZF2", "CXCR5", "BCL6", "KLRB1", "CCR4", "TBX21", "GATA3", "IL2", "IL4", "IFNG")

Idents(hl.combined) <- factor(Idents(hl.combined), 
                              levels = rev(c(
                                         "CD4 T cells_primary", "CD4 T cells_relapse",
                                         "Cytotoxic T cells_primary", "Cytotoxic T cells_relapse",
                                         "Naive T cells_primary", "Naive T cells_relapse",
                                         "Tregs_primary", "Tregs_relapse", 
                                         "B cells_primary", "B cells_relapse",
                                         "germinal centre B cells_primary", "germinal centre B cells_relapse",
                                         "macrophages_primary", "macrophages_relapse",
                                         "NK cells_primary", "NK cells_relapse",
                                         "Plasmacytoid DC_primary", "Plasmacytoid DC_relapse",
                                         "Plasma Cells_primary", "Plasma Cells_relapse"
                                         )))

DotPlot(hl.combined, 
        features = rev(markers.to.plot), 
        cols = c("blue", "red"), 
        dot.scale = 8) + 
  RotatedAxis()

# plot expression by average expression of each gene
cluster.averages <- AverageExpression(hl.combined, return.seurat = TRUE)
DoHeatmap(cluster.averages, features = unlist(markers.to.plot), size = 3, draw.lines = FALSE)

component.mappings <- readxl::read_excel("/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/data/component_genes_with_functions.xlsx", col_names = TRUE)

# extract expression to plot in pheatmap
expr.hl_markers <- hl.combined@assays[["RNA"]]
# this command does the same thing:
#counts.hl_markers <- GetAssayData(object = hl.combined, slot = "counts")


```

Identify differentially expressed genes across conditions

```{r}
# add column to meta.data slot to contain information on cell type and dataset (primary vs. relapse)
hl.combined$celltype.dataset <- paste(Idents(hl.combined), hl.combined$case_type, sep = "_")
hl.combined$celltype <- Idents(hl.combined)
Idents(hl.combined) <- "celltype.dataset"
Idents(hl.combined) <- "celltype"

# violin plot split by dataset (primary vs. relapse) per gene showing expression across clusters

# B and T cells
markers.to.plot <- c("CD3D", "MS4A1")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 1)

# other clusters
markers.to.plot <- c("SDC1", "NRP1", "GZMK")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 1)

# LAG3 and CTLA4
markers.to.plot <- c("CTLA4", "LAG3")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 1)

# top differentially expressed genes in cluster 10 (primary cases only)
markers.to.plot <- c("ISG15", "IFI6", "IFIT3", "IFI44L", "MX1", "IFIT1")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 2)

# annotated genes that seem to be higher in primary vs. relapse
markers.to.plot <- c("TNFSF10", "IL7R", "STAT1", "CCR7", "JUNB", "CD3E", "CD3G", "TRAC")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 1)

markers.to.plot <- c("TNFSF10", "IRF1")
plots <- VlnPlot(hl.combined, features = markers.to.plot, split.by = "case_type", group.by = "celltype", pt.size = 0, combine = FALSE)
CombinePlots(plots = plots, ncol = 1)

#FeaturePlot(hl.combined, features = c("TBX21", "GATA3", "IL17A", "RORC", "LAG3", "CD4", "IRF1"), min.cutoff = "q9")


# Now find differentially expression markers for each cluster
cluster10.cells <- subset(hl.combined, idents = c("10_primary", "10_relapse"))
Idents(cluster10.cells) <- "case_type"
avg.cluster10.cells <- log1p(AverageExpression(cluster10.cells, verbose = FALSE)$RNA)
avg.cluster10.cells$gene <- rownames(avg.cluster10.cells)
genes.to.label = c("CD8A", "CD8B", "TNFSF10", "GZMA", "GZMK")
p <- ggplot(avg.cluster10.cells, aes(primary, relapse)) + geom_point() + ggtitle("cluster 10 cells")
p <- LabelPoints(plot = p, points = genes.to.label, repel = TRUE, xnudge = 0, ynudge = 0)

cluster10.de_genes <- FindMarkers(hl.combined, ident.1 = "10_primary", ident.2 = "10_relapse", verbose = FALSE)
write.table(cluster10.de_genes, "/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/seurat/output/cluster10_de_markers-primary_v_relapse.txt", quote = FALSE, sep = "\t")
```





















3d. Application of a linear transformation ("scaling") (standard pre-processing step prior to dimensionality reduction techniques like PCA) -- `ScaleData` function:
- Shifts the expression of each gene, so that mean expression across cell is 0
- Scales the expression of each gene, so that variances across cells is 1
  - This step gives equal weight in downstream analysis, so highly expressed genes do not dominate
- Result is stored in pbmc[["RNA"]]@scale.data

```{r}
all.genes <- rownames(hl_relapse)
hl_relapse <- ScaleData(hl_relapse, features = all.genes)
```

4. Perform linear dimensional reduction

```{r}
# perform PCA on the scaled data.  Only previously defined variable features are used as input, but can be re-defined using the features argument to choose a different subset
hl_relapse <- RunPCA(hl_relapse, features = VariableFeatures(object = hl_relapse))

# Examine and visualize PCA results in a few different ways
print(hl_relapse[["pca"]], dims = 1:5, nfeatures = 5)

# plot loadings for specified PCA components (in this case, from 1 to 2)
VizDimLoadings(hl_relapse, dims = 1:2, reduction = "pca")
```

`DimHeatmap` allows for easy exploration of the primary sources of heterogeneity in a dataset, and can be useful when trying to decide *which PCs* to include for further downstream analysis. Both cells and features are ordered according to their PCA scores.  Setting `cells` to a number plots the "extreme" cells on both ends of the spectrum, which dramatically speeds plotting for large dataset (e.g. 'cells = 500' --> plots 500 cells??)

Recommendations - err on the higher side for number of PCs to include; re-running analysis with a different number often will not change the results dramatically.

```{r}

# Dimension reduction plot - graph of output from dimension reduction on a 2D scatter
DimPlot(hl_relapse, reduction = "pca")

# Plot PCA dimension 1
DimHeatmap(hl_relapse, dims = 1, cells = 500, balanced = TRUE)

# Plot the first 15 PCA dimensions
DimHeatmap(hl_relapse, dims = 1:15, cells = 500, balanced = TRUE, ncol = 5)
```

Determine the "dimensionality" of the dataset.

Seurat clusters cells based on PCA scores, with each PC essentially representing a "metafeature" that combines information across a correlated feature set.  The top principal components thus represent a robust compression of the dataset.... but how many components should we include ... 10? 20? 100?

`JacksonStrawPlot` function provides visualization tool for comparing distribution of p-values for each PC with a uniform distribution. "Significant" PCs will show a strong enrichment of features with low p-values.

```{r}
hl_relapse <- JackStraw(hl_relapse, num.replicate = 100)
hl_relapse <- ScoreJackStraw(hl_relapse, dims = 1:20)
JackStrawPlot(hl_relapse, dims = 1:15)
```

Alternative heuristic method: "Elbow plot" - ranking of principle components based on % of variance explained by each one --> `ElbowPlot` function.

```{r}
ElbowPlot(hl_relapse) # in this example, see an elbow around 9-10, suggesting majority of true signal is in first 10 PCs
```

5. Cluster the cells

Seurat applies an dramatically improved graph-based clustering approach, driven by the distance metric (based on previously identified PCs) - inspired by SNN-Cliq and PhenoGraph.  Briefly, these methods embed cells in a graph structure (e.g. K-nearest neighbour graph) with edges drawn between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected 'quasi-cliques' or 'communities'. 

Overview of method:
1. Construct KNN graph based on euclidean distance in PCA space (similar to Phenograph)
2. Refine edge weights between any two cells based on shared overlap in local neighbourhoods (Jaccard similarity) --> `FindNeighbours` function (input = previously defined dimensionality of the dataset - i.e. first 10 PCs)
3. To cluster cells, apply modularity optimization techniques (e.g. Louvain algorithm - default, or SLM) to iteratively group cells together, with goal of optimizing the standard modularity function --> `FindClusters` (parameter for "granularity" of downstream clustering where increased values --> increased number of clusters; 0.4-1.2 generally returns good results for single-cell datasets ~3000 cells).
4. Obtain clusters with `Idents` function.

```{r}
hl_relapse <- FindNeighbors(hl_relapse, dims = 1:20) # based on elbow plot, looks like the first 20 PCs carry info
hl_relapse <- FindClusters(hl_relapse, resolution = 0.5)
```

```{r}
# Look at cluster IDs of the first 5 cells
head(Idents(hl_relapse), 5)
```

Run non-linear dimensional reduction (UMAP/tSNE).

Seurat has a few non-linear dimensional reduction techniques (e.g. tSNE, UMAP) to visualize and explore these datasets.  The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space.  Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots.  

```{r}
# optimizations for improved visualization with tSNE / UMAP:
#   - learning.rate	= total number of cells (n) / 12, in n/12 > 200
#   - perplexity ??

hl_relapse <- RunUMAP(hl_relapse, dims = 1:20)
hl_relapse <- RunTSNE(hl_relapse, dims = 1:20)

DimPlot(hl_relapse, reduction = "umap", label = TRUE)
#DimPlot(hl_relapse, reduction = "pca")

saveRDS(hl_relapse, "~/Documents/projects/lsarp_hl_sc_relapse/seurat/hl_relapse_8_libs_20191207.rds") # save as R file object (readRDS to read back in)
```

Finding differentially expressed features (cluster biomarkers).

Seurat can help to find markers that define clusters via differential expression.  By default, positive and negative markers of a single cluster (specified in `ident.l`) are identified compared to all other cells. `FindAllMarkers` automates this process for all clusters, but you can also test groups of clusters vs. each other or against all cells.

The `min.pct` argument requires a feature to be detected at a minimum percentage in either of the two groups of cells and `thresh.test` arguement requires a feature to be differentially expression (on average) by some amount between the two groups (if both are set to 0 --> require much more time since will be testing a large number of features that are unlikely to be discriminatory); can also set `max.cells.per.iden` to speed up computations --> downsamples each identity class to have no more cells than specified threshold.

```{r}
# find all markers of cluster 1
cluster1.markers <- FindMarkers(hl_relapse, 
                                ident.1 = 1, # cluster 1
                                min.pct = 0.25, # default 0.1 (test genes detected in min.pct of cells, for either pop)
                                )
head(cluster1.markers, n=5)

```

```{r}
# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- FindMarkers(hl_relapse, ident.1 = 5, ident.2 = c(0,3), min.pct = 0.25)
head(cluster5.markers, n=5)
```

```{r}
# find markers for every cluster compare to all remaining cells and report only positive ones
hl_relapse.markers <- FindAllMarkers(hl_relapse, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# display the top 10 DE genes per cluster
top_10_per_cluster <- hl_relapse.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
write.table(top_10_per_cluster, "/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/seurat/output/top10_markers_per_cluster-20_PCs.txt", sep = "\t", quote = FALSE, row.names = FALSE)

# get classification power using ROC test
hl_relapse.markers.ROC <- FindAllMarkers(hl_relapse, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = "roc")
top_10_per_cluster.ROC <- hl_relapse.markers.ROC %>% group_by(cluster) %>% top_n(n = 10, wt = power)
write.table(top_10_per_cluster.ROC, "/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/seurat/output/top10_markers_per_cluster-20_PCs-ROC_power.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

Seurat has several tests for differential expression that can be set with the test.use parameter - e.g. ROC test returns "classification power" for any individual marker (where 0 = random... 1 = perfect)

```{r}
cluster1.markers <- FindMarkers(hl_relapse, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)

# see https://satijalab.org/seurat/v3.0/de_vignette.html for other tests that can be used for differential expression.

# if you look at the head and tail of these results, you will notice that the results are sorted by decreasing power (i.e. top gene has the highest "classification power" - closest to 1)
```

Seurat provides several tools for visualizing marker expression - most commonly used visualizations:
(i) `VlnPlot` (shows expression probability distributions across clusters)
(ii) `FeaturePlot` (visualizes feature expression on a tSNE / PCA plot)

Other useful visualization methods: `RidgePlot`, `CellScatter`, `DotPlot`

```{r}
VlnPlot(hl_relapse, features = c("MS4A1", "CD3D"), pt.size = 0.05)

# plot the top biomarkers of each cluster based on "classification power"
VlnPlot(hl_relapse, features = c("MT-ND3", "CD74", "IL32", "RPS14", "MALAT1", "HLA-DRB5", "FOS", "JUN", "MALAT1", "CD74", "CCL5", "GAPDH"), pt.size = 0.01, ncol = 4)
```

# can plot raw counts too

```{r}
VlnPlot(hl_relapse, features = c("NkG7", "PF4"), slot = "counts", log = TRUE)
```

The FeaturePlot:

```{r}
FeaturePlot(hl_relapse, features = c("MT-ND3", "CD74", "IL32", "RPS14", "MALAT1", "HLA-DRB5", "FOS", "JUN", "MALAT1", "CD74", "CCL5", "GAPDH"), pt.size = 0.1, ncol = 4)
```

`DoHeatmap` generates an expression heatmap for given cells and features. In this case, we are plotting top 20 markers (or all markers if there are less than 20) for each cluster.

```{r}
top10 <- hl_relapse.markers %>% group_by(cluster) %>% top_n(n=5, wt=avg_logFC)
DoHeatmap(hl_relapse, features = top10$gene, size = 4, angle = 0, raster = FALSE) # clear PDF, but fuzzy PNG
DoHeatmap(hl_relapse, features = top10$gene, size = 4, angle = 0, raster = TRUE)
```

Assigning cell type identity to clusters.

For this particular dataset, we are able to use canonical markers to easily match the unbiased clustering to known cell types.

```{r}
# print out markers that have a cell type (component) mapping
component_mappings <- read.table("/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/data/genes_with_component_mappings.txt", sep = "\t", header = TRUE)
hl_relapse.markers.components <- dplyr::filter(hl_relapse.markers, hl_relapse.markers$gene %in% component_mappings$gene)
write.table(hl_relapse.markers.components, "/Volumes/shung/projects/LSARP-sc_HL_relapse_vs_primary/seurat/output/component_markers_per_cluster-20_PCs.txt", sep = "\t", quote = FALSE, row.names = FALSE)

# now plot UMAP with new cluster labels
#new.cluster.ids <- c("0", "1", "2", "3", 
#                     "4", "5", "6", "7", 
#                     "8", "9", "10", "11", 
#                     "12", "13", "14", "15", "16")

new.cluster.ids <- c("Unknown", "B", "mix", "Naive T", 
                     "B (2)", "B (3)", "B (4)", "mix (2)", 
                     "Unknown (2)", "B (5)", "mix (3)", "Co-stimulatory molecule", 
                     "mix (4)", "mix (5)", "mix (6)", "B (6)", "T helper")
names(new.cluster.ids) <- levels(hl_relapse)
hl_relapse <- RenameIdents(hl_relapse, new.cluster.ids)
DimPlot(hl_relapse, reduction = "umap", label = TRUE)
```



Create customized heatmaps to visualize expression (e.g. LAG3)

```{r}
# get the expression data
GetAssayData(object = hl_relapse, slot = 'scale.data')[1:3, 1:3]
```

